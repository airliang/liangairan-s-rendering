#include "bvhaccel.hlsl"
#include "sampler.hlsl"
#include "materials.hlsl"
#include "light.hlsl"
#include "distributions.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform int    lightsNum;
uniform int    bounces;
uniform float2 rasterSize;
uniform int    queueSizeIndex;

StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<ShadowRay>  ShadowRays;
StructuredBuffer<Light> lights;
StructuredBuffer<Material> materials;
//StructuredBuffer<ShadingMaterial>  _ShadingMaterials;
//StructuredBuffer<int>    pathStates;
//x pdf y cdf
StructuredBuffer<float2> Distributions1D;
StructuredBuffer<uint> _RayQueueSizeBuffer;
StructuredBuffer<uint> _RayQueue;
//RWTexture2D<half4> outputTexture;



ShadowRay SampleShadowRay(Light light, Interaction isect, inout RNG rng)
{
	ShadowRay shadowRay = (ShadowRay)0;
	/*
	int discriptIndex = light.distributionDiscriptIndex;
	DistributionDiscript lightDistributionDiscript = DistributionDiscripts[discriptIndex];
	float u = Get1D(rng);
	float triPdf = 0;
	float lightPdf = 0;
	MeshInstance meshInstance = MeshInstances[light.meshInstanceID];
	int triangleIndex = SampleTriangleIndexOfLightPoint(u, lightDistributionDiscript, Distributions1D, lightPdf) * 3 + meshInstance.triangleStartOffset;

	int vertexStart = triangleIndex;
	int vIndex0 = TriangleIndices[vertexStart];
	int vIndex1 = TriangleIndices[vertexStart + 1];
	int vIndex2 = TriangleIndices[vertexStart + 2];
	float3 p0 = Vertices[vIndex0].position.xyz;
	float3 p1 = Vertices[vIndex1].position.xyz;
	float3 p2 = Vertices[vIndex2].position.xyz;
	//convert to worldpos
	
	p0 = mul(meshInstance.localToWorld, float4(p0, 1)).xyz;
	p1 = mul(meshInstance.localToWorld, float4(p1, 1)).xyz;
	p2 = mul(meshInstance.localToWorld, float4(p2, 1)).xyz;

	float3 samplePointOnLight;
	float3 wi;
	
	float3 Li = SampleTriangleLight(p0, p1, p2, Get2D(rng), isect, light, wi, samplePointOnLight, triPdf);
	lightPdf *= triPdf;
	*/
	
	float3 wi;
	float lightPdf = 0;
	float3 samplePointOnLight;
	float3 Li = SampleLightRadiance(Distributions1D, light, isect, rng, wi, lightPdf, samplePointOnLight);

	if (lightPdf > 0 && !IsBlack(Li))
	{
		shadowRay.p0 = isect.p.xyz;
		shadowRay.p1 = samplePointOnLight;
		//shadowRay.pdf = triPdf;
		shadowRay.lightPdf = lightPdf;
		//float3 Li = light.radiance;
		//shadowRay.lightNormal = lightPointNormal;
		//float3 wi = normalize(shadowRay.p1 - shadowRay.p0);

		//sample bsdf
		Material material = materials[isect.materialID];
		float3 wiLocal = isect.WorldToLocal(wi);
		float3 woLocal = isect.WorldToLocal(isect.wo.xyz);
		float scatteringPdf = 0;
		float mipmapLevel = 0;
		float3 f = MaterialBRDF(material, isect, woLocal, wiLocal, scatteringPdf);
		f *= abs(dot(wi, isect.normal));
		//float3 f = LambertBRDF(wiLocal, woLocal, material.kd.xyz) * abs(dot(wi, isect.normal));
		//scatteringPdf = LambertPDF(wiLocal, woLocal);

		bool shadowRayVisible = ShadowRayVisibilityTest(shadowRay, isect.normal);

		if (shadowRayVisible)
		{
			//sample psdf and compute the mis weight
			float weight =
				PowerHeuristic(1, lightPdf, 1, scatteringPdf);
			shadowRay.radiance = f * Li * weight / lightPdf;
		}
	}
	
	return shadowRay;
}



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
	if (threadId >= queueSize)
		return;
	uint workIndex = _RayQueue[threadId];
	RNG rng = GetRNG(threadId);
	//int pathState = pathStates[threadId];

	float lightSourcePdf = 1.0;
	//some error happen in SampleLightSource
	float u = Get1D(rng);//rs.Get1D(workIndex);
	int lightIndex = SampleLightSource(u, lightsNum, Distributions1D, lightSourcePdf);
	Light light = lights[lightIndex];
	//float testD = Distributions1D[0].y;
	Interaction isect = Intersections[workIndex];
	ShadowRay shadowRay = SampleShadowRay(light, isect, rng);
	shadowRay.lightSourcePdf = lightSourcePdf;
	shadowRay.lightIndex = asfloat(lightIndex);
	ShadowRays[workIndex] = shadowRay;

	WriteRNG(threadId, rng);
}
