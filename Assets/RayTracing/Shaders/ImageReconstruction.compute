#include "GPUStructs.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
float2 rasterSize;
int framesNum;
StructuredBuffer<PathRadiance> pathRadiances;
RWStructuredBuffer<float3>  spectrums;
RWTexture2D<half4> outputTexture;

float3 XYZToRGB(float3 xyz) {
    return float3(3.240479f * xyz.x - 1.537150f * xyz.y - 0.498535f * xyz.z,
                 -0.969256f * xyz.x + 1.875991f * xyz.y + 0.041556f * xyz.z,
                  0.055648f * xyz.x - 0.204043f * xyz.y + 1.057311f * xyz.z);
}

inline half3 LinearToGammaSpace(half3 linRGB)
{
    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));
    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);

    // Exact version, useful for debugging.
    //return half3(LinearToGammaSpaceExact(linRGB.r), LinearToGammaSpaceExact(linRGB.g), LinearToGammaSpaceExact(linRGB.b));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
        return;

    int threadId = id.x + id.y * rasterSize.x;
    float4 color = outputTexture[id.xy];
    PathRadiance pathRadiance = pathRadiances[threadId];
    float3 radiance = LinearToGammaSpace(pathRadiance.li.rgb);//XYZToRGB(pathRadiance.li.rgb);
    float3 spectrum = spectrums[threadId];
    spectrum.rgb += radiance;
    spectrums[threadId] = spectrum;
    color.rgb = spectrum / framesNum;
    color.a = 1;
    outputTexture[id.xy] = color;
}
