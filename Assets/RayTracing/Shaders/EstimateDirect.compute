// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "sampler.hlsl"
#include "materials.hlsl"
#include "bvhaccel.hlsl"
#include "distributions.hlsl"
#include "light.hlsl"

cbuffer cb
{
    int    bounces;
    //int    lightsNum;
    float2 rasterSize;
    int    queueSizeIndex;
};

StructuredBuffer<Interaction>  Intersections;
StructuredBuffer<ShadowRay>  ShadowRays;
StructuredBuffer<Light> lights;
StructuredBuffer<Material> materials;
//StructuredBuffer<ShadingMaterial>  _ShadingMaterials;
RWStructuredBuffer<PathRadiance> pathRadiances;
//StructuredBuffer<int>    pathStates;
//x pdf y cdf
StructuredBuffer<float2> Distributions1D;
RWStructuredBuffer<uint> _RayQueueSizeBuffer;
RWStructuredBuffer<uint> _RayQueue;
RWStructuredBuffer<Ray>   Rays;
//RWTexture2D<half4> outputTexture;

float AreaLightPdf(Ray ray, Light light, float3 orig, float3 wi)
{
    float lightPdf = 0;
    if (light.type == AreaLightType)
    {
        //intersect the light mesh triangle
        float bvhHit = ray.tmax;
        int meshHitTriangleIndex;  //wood triangle addr

        DistributionDiscript discript = DistributionDiscripts[light.distributionDiscriptIndex];
        int distributionIndex = discript.start;
        //getting the mesh of the light
        MeshInstance meshInstance = MeshInstances[light.meshInstanceID];

        //convert to mesh local space
        Ray rayTemp = TransformRay(meshInstance.worldToLocal, ray);

        //check the ray intersecting the light mesh
        if (IntersectMeshBVHP(rayTemp, meshInstance.GetBVHOffset(), bvhHit, meshHitTriangleIndex))
        {
            int triAddr = meshHitTriangleIndex;
            int vIndex0 = WoodTriangleIndices[triAddr];
            int vIndex1 = WoodTriangleIndices[triAddr + 1];
            int vIndex2 = WoodTriangleIndices[triAddr + 2];
            float3 p0 = Vertices[vIndex0].position.xyz;
            float3 p1 = Vertices[vIndex1].position.xyz;
            float3 p2 = Vertices[vIndex2].position.xyz;

            p0 = mul(meshInstance.localToWorld, float4(p0, 1.0));
            p1 = mul(meshInstance.localToWorld, float4(p1, 1.0));
            p2 = mul(meshInstance.localToWorld, float4(p2, 1.0));

            lightPdf = 1.0 / length(cross(p0 - p1, p0 - p2));

            distributionIndex += vIndex0 / 3;

            lightPdf *= DiscretePdf(distributionIndex, Distributions1D);
        }
    }
    else if (light.type == EnvLightType)
    {
        lightPdf = INV_FOUR_PI;
    }

    return lightPdf;
}


float3 EstimateDirect(Interaction isect, Material material, inout RNG rng, out float scatteringPdf, out float3 wi)
{
    //float3 Ld = shadowRay.radiance;
    float3 woLocal = isect.WorldToLocal(isect.wo);
    //float3 wi;
    //float scatteringPdf = 0;
    float3 wiLocal;
    float2 u = Get2D(rng);
    float3 f = SampleMaterialBRDF(material, isect, woLocal, wiLocal, scatteringPdf, rng);
    
    wi = isect.LocalToWorld(wiLocal);
    //f *= abs(dot(wi, isect.normal));

    return f;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= rasterSize.x || id.y >= rasterSize.y)
        return;

    uint threadId = id.x + id.y * rasterSize.x;
    uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
    if (threadId >= queueSize)
        return;
    uint workIndex = _RayQueue[threadId];
    RNG rng = GetRNG(threadId);

    ShadowRay shadowRay = ShadowRays[workIndex];
    Interaction isect = Intersections[workIndex];
    PathRadiance pathRadiance = pathRadiances[workIndex];
    Material material = materials[isect.materialID];
    //float2 u = Get2D(rng);//rs.Get2D(workIndex);
    float3 beta = 1; // = pathRadiance.beta;
    float scatteringPdf = 0;
    float3 wi;
    float3 f = EstimateDirect(isect, material, rng, scatteringPdf, wi);
    float3 Li = shadowRay.radiance;  
    Ray ray;
    if (scatteringPdf > 0)
    {
        beta = f * abs(dot(wi, isect.normal)) / scatteringPdf;
        Light light = lights[asint(shadowRay.lightIndex)];

        ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);

        float lightPdf = AreaLightPdf(ray, light, isect.p, wi);
        if (lightPdf > 0)
        {
            //caculate the mis weight
            float weight = PowerHeuristic(1, lightPdf, 1, scatteringPdf);
            Li += Light_Le(wi, light) * beta * weight;//f * light.radiance * weight / scatteringPdf;
        }
    }
    
    Li /= shadowRay.lightSourcePdf;
    pathRadiance.li += Li * pathRadiance.beta;

    if (scatteringPdf > 0)
    {
        bool breakPath = false;
        pathRadiance.beta *= beta;

        if (bounces > 3)
        {
            float q = max(0.05, 1 - MaxComponent(pathRadiance.beta));
            if (Get1D(rng) < q)
            {
                breakPath = true;
            }
            else
                pathRadiance.beta /= 1 - q;
        }

        if (!breakPath)
        {
            Rays[workIndex] = ray;
            uint index;
            InterlockedAdd(_RayQueueSizeBuffer[queueSizeIndex + 1], 1, index);
            _RayQueue[index] = workIndex;
        }
    }
    //outputTexture[id.xy] = half4(pathRadiance.li * 5, 1);
    pathRadiances[workIndex] = pathRadiance;
    WriteRNG(threadId, rng);
}
