#include "sampler.hlsl"
#include "rtCommon.hlsl"
#include "materials.hlsl"
#include "light.hlsl"
// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel RayMiss


int bounces;
float2 rasterSize;
int   queueSizeIndex;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

StructuredBuffer<EscapeRayItem>  EscapeRays;
RWStructuredBuffer<PathRadiance> pathRadiances;
StructuredBuffer<uint> _EscapeQueueSizeBuffer;

[numthreads(8, 8, 1)]
void RayMiss(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	uint queueSize = _EscapeQueueSizeBuffer[bounces];
	if (threadId >= queueSize)
		return;
	uint pixelIndex = threadId;

	PathRadiance pathRadiance = pathRadiances[pixelIndex];
	EscapeRayItem rayItem = EscapeRays[threadId];

	if (bounces == 0)
	{
		if (_EnvLightIndex >= 0)
		{
			pathRadiance.li += rayItem.throughput * EnviromentLightLe(rayItem.direction);
			pathRadiances[pixelIndex] = pathRadiance;
		}
	}
	else
	{

	}
}
