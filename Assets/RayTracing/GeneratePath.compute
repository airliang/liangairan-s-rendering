#include "sampler.hlsl"
#include "rtCommon.hlsl"
#include "bxdf.hlsl"
#include "light.hlsl"
// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel GeneratePath

cbuffer cb
{
	int bounces;
	float2 rasterSize;
};
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


RWStructuredBuffer<Ray>   Rays;
StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<PathRadiance> pathRadiances;
StructuredBuffer<Material> materials;

[numthreads(8, 8, 1)]
void GeneratePath(uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	if (id.x >= rasterSize.x || id.y >= rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	Interaction isect = Intersections[threadId];

	if (isect.IsHit())
	{
		PathRadiance pathRadiance = pathRadiances[threadId];
		float3 beta = pathRadiance.beta;
		Material material = materials[isect.materialID];
		float3 woLocal = isect.WorldToLocal(isect.wo);
		float3 wi;
		float scatteringPdf = 0;
		float3 wiLocal;
		float2 u = rs.Get2D(threadId);
		float3 f = SampleLambert(material, woLocal, wiLocal, u, scatteringPdf);
		wi = isect.LocalToWorld(wiLocal);
		beta *= f * abs(dot(wi, isect.normal)) / scatteringPdf;

		Ray ray;
		ray.orig = float4(isect.p.xyz, FLT_MAX);
		ray.direction = float4(wi, 0);

		Rays[threadId] = ray;

		if (bounces > 3)
		{
			float q = max((Float).05, 1 - beta.y);
			if (rs.Get1D(threadId) < q)
			{
				pathRadiance.beta = 0;
			}
			else
				pathRadiance.beta /= 1 - q;
		}
	}


}
