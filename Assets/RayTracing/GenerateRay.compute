#include "sampler.hlsl"
#include "GPUStructs.hlsl"
#include "bxdf.hlsl"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GeneratePrimary


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

//use the matrix to calculate the world space ray
matrix RasterToCamera;
matrix CameraToWorld;
float2 rasterSize;

RWStructuredBuffer<Ray>    Rays;
RWStructuredBuffer<PathRadiance> pathRadiances;
[numthreads(8,8,1)]
void GeneratePrimary(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= rasterSize.x || id.y >= rasterSize.y)
        return;
    uint threadId = id.x + id.y * rasterSize.x;

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    CameraSample cSample = rs.GetCameraSample(float2(id.x, id.y), threadId); //rs.GetCameraSample(float2(id.x, id.y), _time);
    float3 pFilm = float3(cSample.pFilm, 0);
    float4 nearplanePoint = mul(RasterToCamera, float4(pFilm, 1));
    nearplanePoint /= nearplanePoint.w;

    Ray ray;
    ray.orig = mul(CameraToWorld, float4(0, 0, 0, 1));
    ray.direction = mul(CameraToWorld, float4(normalize(nearplanePoint.xyz), 0));
    ray.orig.w = FLT_MAX;
    Rays[threadId] = ray;
    PathRadiance bounceRadiance;
    bounceRadiance.li = 0;
    bounceRadiance.beta = 1.0;
    pathRadiances[threadId] = bounceRadiance;
}

