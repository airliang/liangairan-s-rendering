// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PrefilterIrradiancemap
#define PI 3.14159265359
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture3D<float4> EnviromentCube;
uniform float textureWidth;
uniform int   cubeSize;

[numthreads(8,8,1)]
void PrefilterIrradiancemap(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
	float textureHeight = textureWidth * 0.5;

	float phi = id.x / textureWidth * 2 * PI;
	float sita = id.y / textureHeight * PI;
	float sinPhi = sin(phi);
	float cosPhi = cos(phi);
	float sinSita = sin(sita);
	float cosSita = cos(sita);
	float3 normalDirection = float3(sinSita * cosPhi, cosSita, sinSita * sinPhi);
	normalDirection = normalize(normalDirection);

	float3 irradiance = float3(0, 0, 0);
	float3 up = float3(0.0, 1.0, 0.0);
	float3 right = cross(up, normalDirection);
	up = cross(normalDirection, right);

	float sampleDelta = 0.025;
	float nrSamples = 0.0;
	for (phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
	{
		for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
		{
			// spherical to cartesian (in tangent space)
			float3 tangentSample = float3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
			// tangent space to world
			float3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normalDirection;

			irradiance += EnviromentCube[(uint3)(sampleVec * cubeSize)].rgb * cos(theta) * sin(theta);
			nrSamples += 1.0;
		}
	}
	irradiance = PI * irradiance * (1.0 / float(nrSamples));

    Result[id.xy] = float4(irradiance, 1.0);
}
