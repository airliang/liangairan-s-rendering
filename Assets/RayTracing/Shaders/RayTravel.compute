#include "sampler.hlsl"
#include "bvhaccel.hlsl"
#include "materials.hlsl"
#include "light.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayTraversal

//#pragma multi_compile __ _ENVMAP_ENABLE
//#pragma multi_compile _ _UNIFORM_SAMPLE_LIGHT

float2 rasterSize;
uniform int    bounces;
uniform int   curQueueSizeIndex;



//use the matrix to calculate the world space ray
StructuredBuffer<Ray>    Rays;
RWStructuredBuffer<Interaction>       Intersections;
RWStructuredBuffer<PathRadiance> pathRadiances;
//RWStructuredBuffer<int>    pathStates;
RWStructuredBuffer<uint> _RayQueueSizeBuffer;
RWStructuredBuffer<uint> _RayQueue;
//RWStructuredBuffer<ShadingMaterial>  _ShadingMaterials;

//x : first hit pixel spread angle, y: previous hit cone width
RWTexture2D<half4>  RayConeGBuffer;
//RWTexture2D<float3> LastISectRayCone;

//RWTexture2D<half4> outputTexture;

[numthreads(8,8,1)]
void RayTraversal(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
        return;

    int threadId = id.x + id.y * rasterSize.x;
    
    uint pixelIndex = threadId;

    Ray ray = Rays[pixelIndex];
    Interaction isect = (Interaction)0;//Intersections[threadId];
    //float3 lastCone = LastISectRayCone[id.xy];
    half4 gbuffer = RayConeGBuffer[id.xy];
    PathRadiance pathRadiance = (PathRadiance)0;
    pathRadiance.beta = 1;
    //bool foundIntersect = false;
    if (bounces == 0)
    {
        bool foundIntersect = ClosestHit(ray, isect);
        if (foundIntersect)
        {
            int meshInstanceIndex = isect.meshInstanceID;
            MeshInstance meshInstance = MeshInstances[meshInstanceIndex];
            int lightIndex = meshInstance.GetLightIndex();

            if (lightIndex >= 0)
            {
                Light light = lights[lightIndex];
                pathRadiance.li += pathRadiance.beta * light.radiance;
                pathRadiances[pixelIndex] = pathRadiance;
            }
            else
            {
                RayCone rayCone;
                rayCone.spreadAngle = cameraConeSpreadAngle;
                rayCone.width = cameraConeSpreadAngle * isect.hitT;
                isect.coneWidth = rayCone.width;
                gbuffer.y = rayCone.spreadAngle + gbuffer.x;
                RayConeGBuffer[id.xy] = gbuffer;
                Intersections[pixelIndex] = isect;
                
                uint index;
                InterlockedAdd(_RayQueueSizeBuffer[curQueueSizeIndex], 1, index);
                _RayQueue[index] = pixelIndex;
            }
            
        }
        else
        {
            //sample enviroment map
            if (_EnvLightIndex >= 0)
            {
                pathRadiance.li += pathRadiance.beta * EnviromentLightLe(ray.direction);
                pathRadiances[pixelIndex] = pathRadiance;
                return;
            }
        }
    }
    else
    {
        uint queueSize = _RayQueueSizeBuffer[curQueueSizeIndex];
        if (threadId >= queueSize)
            return;
        pixelIndex = _RayQueue[threadId];
        //pathRadiance = pathRadiances[pixelIndex];
        isect = Intersections[pixelIndex];
        //half2 surfaceBeta = RayConeGBuffer[id.xy];
        RayCone preCone;
        preCone.width = gbuffer.z;
        preCone.spreadAngle = gbuffer.y;
        RayCone rayCone = ComputeRayCone(preCone, isect.coneWidth, gbuffer.x);
        isect.coneWidth = rayCone.width;
        gbuffer.y = rayCone.spreadAngle;
        RayConeGBuffer[id.xy] = gbuffer;
        Intersections[pixelIndex] = isect;
    }

    //pathRadiances[pixelIndex] = pathRadiance;
	
}
