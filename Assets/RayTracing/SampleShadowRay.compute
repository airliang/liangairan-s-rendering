#include "bvhaccel.hlsl"
#include "sampler.hlsl"
#include "bxdf.hlsl"
#include "light.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform int    lightsNum;
uniform int    bounces;
uniform float2 rasterSize;


StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<ShadowRay>  ShadowRays;
StructuredBuffer<Light> lights;
StructuredBuffer<Material> materials;
StructuredBuffer<int>    pathStates;
//RWTexture2D<half4> outputTexture;

Light SampleLightSource(out float pdf, uint threadId, int lightCount, out int index)
{
	index = SampleDistribution1DDiscrete(rs.Get1D(threadId), 0, lightCount, pdf);
	return lights[index];
}



ShadowRay SampleShadowRay(uint threadId, Light light, Interaction isect)
{
	ShadowRay shadowRay = (ShadowRay)0;
	int distributionAddress = light.distributeAddress;
	float u = rs.Get1D(threadId);
	float triPdf = 0;
	float lightPdf = 0;
	MeshInstance meshInstance = MeshInstances[light.meshInstanceID];
	int triangleIndex = (SampleLightTriangle(distributionAddress, light.trianglesNum, u, lightPdf) - lightsNum) * 3 + meshInstance.triangleStartOffset;
	int vertexStart = triangleIndex;
	int vIndex0 = TriangleIndices[vertexStart];
	int vIndex1 = TriangleIndices[vertexStart + 1];
	int vIndex2 = TriangleIndices[vertexStart + 2];
	float3 p0 = Vertices[vIndex0].position.xyz;
	float3 p1 = Vertices[vIndex1].position.xyz;
	float3 p2 = Vertices[vIndex2].position.xyz;
	//convert to worldpos
	
	p0 = mul(meshInstance.localToWorld, float4(p0, 1)).xyz;
	p1 = mul(meshInstance.localToWorld, float4(p1, 1)).xyz;
	p2 = mul(meshInstance.localToWorld, float4(p2, 1)).xyz;

	//float3 lightPointNormal;
	float3 trianglePoint;
	//SampleTrianglePoint(p0, p1, p2, rs.Get2D(threadId), lightPointNormal, trianglePoint, triPdf);
	float3 wi;
	float3 Li = SampleTriangleLight(p0, p1, p2, rs.Get2D(threadId), isect, light, wi, trianglePoint, triPdf);
	lightPdf *= triPdf;

	if (lightPdf > 0)
	{
		shadowRay.p0 = isect.p.xyz;
		shadowRay.p1 = trianglePoint;
		//shadowRay.pdf = triPdf;
		shadowRay.lightPdf = lightPdf;
		//float3 Li = light.radiance;
		//shadowRay.lightNormal = lightPointNormal;
		//float3 wi = normalize(shadowRay.p1 - shadowRay.p0);

		//sample bsdf
		Material material = materials[isect.materialID];
		float3 wiLocal = isect.WorldToLocal(wi);
		float3 woLocal = isect.WorldToLocal(isect.wo.xyz);
		float3 f = LambertBRDF(woLocal, wiLocal, material.kd.xyz) * abs(dot(wi, isect.normal));
		float scatteringPdf = LambertPDF(woLocal, wiLocal);
		int meshInstanceIndex = -1;
		float hitT = 0;
		bool shadowRayVisible = ShadowRayVisibilityTest(shadowRay, isect.normal, hitT, meshInstanceIndex);

		if (shadowRayVisible)
		{
			//sample psdf and compute the mis weight
			shadowRay.weight =
				PowerHeuristic(1, lightPdf, 1, scatteringPdf);
			shadowRay.radiance = f * Li * shadowRay.weight / lightPdf;
		}
	}
	
	return shadowRay;
}



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	
	int pathState = pathStates[threadId];
	if (pathState == 1)
	{
		float lightSourcePdf = 1.0;
		int lightIndex = 0;
		//some error happen in SampleLightSource
		Light light = SampleLightSource(lightSourcePdf, threadId, lightsNum, lightIndex);
		//float testD = Distributions1D[0].y;
		Interaction isect = Intersections[threadId];
		ShadowRay shadowRay = SampleShadowRay(threadId, light, isect);
		shadowRay.lightSourcePdf = lightSourcePdf;
		shadowRay.lightIndex = asfloat(lightIndex);
		ShadowRays[threadId] = shadowRay;
		//outputTexture[id.xy] = half4(shadowRay.radiance, 1);
		//if (bounces >= 1)
		//	outputTexture[id.xy] = half4(isect.normal.xyz, 1);
		//else
		//	outputTexture[id.xy] = half4(shadowRay.radiance, 1);
	}
	else
	{
		//outputTexture[id.xy] = half4(1, 0, 0, 1);
	}
}
