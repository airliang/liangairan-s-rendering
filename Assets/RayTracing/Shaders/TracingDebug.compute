#include "sampler.hlsl"
#include "bvhaccel.hlsl"
#include "materials.hlsl"
#include "light.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define NormalView 1
#define DepthView 2
#define MipmapView 3
#define GBuffer    4
#define ShadowRayView  5
#define FresnelView 6

int debugView;
float2 rasterSize;
uniform int    bounces;
uniform int   queueSizeIndex;
uniform float cameraConeSpreadAngle;
uniform float cameraFar;
uniform int    lightsNum;

//use the matrix to calculate the world space ray
StructuredBuffer<Ray>    Rays;
//StructuredBuffer<Light>  lights;
StructuredBuffer<Material> materials;
RWStructuredBuffer<Interaction>       Intersections;
StructuredBuffer<float2> Distributions1D;
StructuredBuffer<Light> lights;

Texture2D<half2>  RayConeGBuffer;
RWTexture2D<half4> outputTexture;

float3 MaterialFresnelShadowRay(Material material, Interaction isect, inout RNG rng)
{
    Light light = lights[0];
    float3 wi;
    float lightPdf = 0;
    float3 samplePointOnLight;
    float3 Li = SampleLightRadiance(Distributions1D, light, isect, rng, wi, lightPdf, samplePointOnLight);
    ShadowRay shadowRay = (ShadowRay)0;
    if (lightPdf > 0)
    {
        shadowRay.p0 = isect.p.xyz;
        shadowRay.p1 = samplePointOnLight;
        //shadowRay.pdf = triPdf;
        shadowRay.lightPdf = lightPdf;
        //float3 Li = light.radiance;
        //shadowRay.lightNormal = lightPointNormal;
        //float3 wi = normalize(shadowRay.p1 - shadowRay.p0);

        bool shadowRayVisible = ShadowRayVisibilityTest(shadowRay, isect.normal);
        if (!shadowRayVisible)
        {
            return 0;
        }
    }
    float3 wo = isect.WorldToLocal(isect.wo.xyz);

    ShadingMaterial shadingMaterial = (ShadingMaterial)0;
    if (shadingMaterial.materialType == Disney)
    {

    }
    else
    {
        UnpackShadingMaterial(material, shadingMaterial, isect);
        int nComponent = 0;
        if (shadingMaterial.materialType == Plastic)
        {
            BxDFPlastic bxdfPlastic;
            ComputeBxDFPlastic(shadingMaterial, bxdfPlastic);
            float pdfMicroReflection = 0;
            return bxdfPlastic.Fresnel(wo, wi);//MicrofacetReflectionF(wo, wi, bxdf, pdfMicroReflection);
        }
        else if (shadingMaterial.materialType == Metal)
        {
            BxDFMetal bxdfMetal;
            ComputeBxDFMetal(shadingMaterial, bxdfMetal);
            float3 wh = wi + wo;
            wh = normalize(wh);
            wh = isect.LocalToWorld(wh);
            return bxdfMetal.Fresnel(wo, wi);  //MicrofacetReflectionF(wo, wi, bxdf, pdf);
        }
        else
        {
            return 0;
        }
    }
    return 0;
}

float3 MaterialFresnel(Material material, Interaction isect, inout RNG rng)
{
    float3 wo = isect.WorldToLocal(isect.wo.xyz);

    ShadingMaterial shadingMaterial = (ShadingMaterial)0;
    UnpackShadingMaterial(material, shadingMaterial, isect);

    switch (shadingMaterial.materialType)
    {
    case Disney:
        return 0;
    case Matte:
    {
        BxDFLambertReflection bxdfLambert;
        ComputeBxDFLambertReflection(shadingMaterial, bxdfLambert);
        float2 u = Get2D(rng);
        return 0;
    }
    case Plastic:
    {
        BxDFPlastic bxdfPlastic;
        ComputeBxDFPlastic(shadingMaterial, bxdfPlastic);
        float2 u = Get2D(rng);
        float3 wh = bxdfPlastic.Sample_wh(u, wo);
        float3 wi = reflect(-wo, wh);
        return bxdfPlastic.Fresnel(wo, wi);
    }
    case Metal:
    {
        BxDFMetal bxdf;
        ComputeBxDFMetal(shadingMaterial, bxdf);
        
        float2 u = Get2D(rng);
        float3 wh = normalize(bxdf.Sample_wh(u, wo));
        float3 wi = normalize(reflect(-wo, wh));
        float scatteringPdf = 0;
        return bxdf.Fresnel(wo, wi);
        //return SampleMetal(shadingMaterial, wo, wi, rng, scatteringPdf);//SampleMaterialBRDF(material, isect, wo, wi, scatteringPdf, rng);
    }
    case Mirror:
        return 0;
    case Glass:
        return 0;
    default:
    {
        return 0;
    }
    }

    return 0;
}

float3 SampleShadowRayRadiance(Light light, Interaction isect, inout RNG rng)
{
	ShadowRay shadowRay = (ShadowRay)0;

	float3 wi;
	float lightPdf = 0;
	float3 samplePointOnLight;
	float3 Li = SampleLightRadiance(Distributions1D, light, isect, rng, wi, lightPdf, samplePointOnLight);

    if (lightPdf > 0)
    {
        shadowRay.p0 = isect.p.xyz;
        shadowRay.p1 = samplePointOnLight;
        //shadowRay.pdf = triPdf;
        shadowRay.lightPdf = lightPdf;
        //float3 Li = light.radiance;
        //shadowRay.lightNormal = lightPointNormal;
        //float3 wi = normalize(shadowRay.p1 - shadowRay.p0);

        bool shadowRayVisible = ShadowRayVisibilityTest(shadowRay, isect.normal);
        if (shadowRayVisible)
        {
            shadowRay.radiance = Li;
        }
    }

	return shadowRay.radiance;
}

float3 FresnelColor(Interaction isect, Light light, inout RNG rng)
{
    
    //float3 wiLocal = isect.WorldToLocal(wi);
    //float3 woLocal = isect.WorldToLocal(isect.wo.xyz);
    Material material = materials[isect.materialID];
    //return MaterialFresnelShadowRay(material, isect, rng);
    return MaterialFresnel(material, isect, rng);
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
        return;

    int threadId = id.x + id.y * rasterSize.x;
    RNG rng = GetRNG(threadId);
    Ray ray = Rays[threadId];
    Interaction isect = (Interaction)0;//Intersections[threadId];

    bool foundIntersect = ClosestHit(ray, isect);//IntersectBVH(ray, isect);
    half3 color = half3(0, 0, 0);
    if (foundIntersect)
    {
        int meshInstanceIndex = isect.meshInstanceID;
        MeshInstance meshInstance = MeshInstances[meshInstanceIndex];
        //int lightIndex = meshInstance.GetLightIndex();

        //if (bounces == 0)
        {
            //half2 surfaceBeta = RayConeGBuffer[id.xy];
            isect.spreadAngle = cameraConeSpreadAngle;
            isect.coneWidth = cameraConeSpreadAngle * isect.hitT;
        }
        //else
        //{
        //    RayCone rayCone = ComputeRayCone(isect, cameraConeSpreadAngle);
        //    isect.spreadAngle = rayCone.spreadAngle;
        //    isect.coneWidth = rayCone.width;
        //}

        switch (debugView)
        {
        case NormalView:
            color = isect.normal * 0.5 + 0.5;
            break;
        case DepthView:
            color = half3(isect.hitT, isect.hitT, isect.hitT) / cameraFar;
            break;
        case MipmapView:
            float mipmapLevel = ComputeTextureLOD(isect) / log2(512);
            color = lerp(half3(0, 0, 1), half3(1, 0, 0), mipmapLevel * 2);
            break;
        case GBuffer:
            color.rg = RayConeGBuffer[id.xy];
            break;
        case ShadowRayView:
        {
            float u = Get1D(rng);
            float lightSourcePdf = 0;
            int lightIndex = SampleLightSource(u, lightsNum, Distributions1D, lightSourcePdf);
            Light light = lights[lightIndex];
            float3 shadowRayRadiance = SampleShadowRayRadiance(light, isect, rng);
            color = shadowRayRadiance;
        }
            break;
        case FresnelView:
        {
            Light light = lights[0];
            color = FresnelColor(isect, light, rng);
        }
            break;
        }

    }
    outputTexture[id.xy] = half4(color, 1);
    WriteRNG(threadId, rng);
}
