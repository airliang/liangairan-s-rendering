#include "bvhaccel.hlsl"
#include "sampler.hlsl"
#include "bxdf.hlsl"
#include "light.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform int    lightsNum;
uniform float2 rasterSize;


StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<ShadowRay>  ShadowRays;
StructuredBuffer<Light> lights;
StructuredBuffer<Material> materials;
RWTexture2D<half4> outputTexture;

Light SampleLightSource(out float pdf, uint threadId, int lightCount, out int index)
{
	index = SampleDistribution1DDiscrete(rs.Get1D(threadId), 0, lightCount, pdf);
	return lights[index];
}



ShadowRay SampleShadowRay(uint threadId, Light light, Interaction isect)
{
	ShadowRay shadowRay = (ShadowRay)0;
	int distributionAddress = light.distributeAddress;
	float u = rs.Get1D(threadId);
	float triPdf = 0;
	float lightPdf = 0;
	MeshInstance meshInstance = MeshInstances[light.meshInstanceID];
	int triangleIndex = (SampleLightTriangle(distributionAddress, light.trianglesNum, u, lightPdf) - lightsNum) * 3 + meshInstance.triangleStartOffset;
	int vertexStart = triangleIndex;
	int vIndex0 = TriangleIndices[vertexStart];
	int vIndex1 = TriangleIndices[vertexStart + 1];
	int vIndex2 = TriangleIndices[vertexStart + 2];
	float3 p0 = Vertices[vIndex0].position.xyz;
	float3 p1 = Vertices[vIndex1].position.xyz;
	float3 p2 = Vertices[vIndex2].position.xyz;
	//convert to worldpos
	
	p0 = mul(meshInstance.localToWorld, float4(p0, 1)).xyz;
	p1 = mul(meshInstance.localToWorld, float4(p1, 1)).xyz;
	p2 = mul(meshInstance.localToWorld, float4(p2, 1)).xyz;

	//float3 lightPointNormal;
	float3 trianglePoint;
	//SampleTrianglePoint(p0, p1, p2, rs.Get2D(threadId), lightPointNormal, trianglePoint, triPdf);
	float3 wi;
	float3 Li = SampleTriangleLight(p0, p1, p2, rs.Get2D(threadId), isect, light, wi, trianglePoint, triPdf);
	lightPdf *= triPdf;

	shadowRay.p0 = isect.p.xyz;
	shadowRay.p1 = trianglePoint;
	//shadowRay.pdf = triPdf;
	shadowRay.lightPdf = lightPdf;
	//float3 Li = light.radiance;
	//shadowRay.lightNormal = lightPointNormal;
	//float3 wi = normalize(shadowRay.p1 - shadowRay.p0);

	//sample bsdf
	Material material = materials[isect.materialID];
	float3 wiLocal = isect.WorldToLocal(wi);
	float3 woLocal = isect.WorldToLocal(isect.wo.xyz);
	float3 f = LambertBRDF(woLocal, wiLocal, material.kd.xyz) * abs(dot(wi, isect.normal));
	float scatteringPdf = LambertPDF(woLocal, wiLocal);
	int meshInstanceIndex = -1;
	float hitT = 0;
	bool shadowRayVisible = ShadowRayVisibilityTest(shadowRay, isect.normal, hitT, meshInstanceIndex);

	//if (!shadowRayVisible && meshInstanceIndex == isect.meshInstanceID && hitT < 0.001)
	//{
	//	shadowRay.radiance = float3(0, 0, 1);
	//}
	//else
	{
		if (shadowRayVisible)
		{
			//sample psdf and compute the mis weight
			shadowRay.weight =
				PowerHeuristic(1, lightPdf, 1, scatteringPdf);
			shadowRay.radiance = f * Li * shadowRay.weight / lightPdf;
		}
		else
		{
			if (meshInstanceIndex == isect.meshInstanceID && hitT < 0.001)
			{
				if (meshInstanceIndex == 4)
				{
					shadowRay.radiance = float3(1, 0, 1);
				}
				else
					shadowRay.radiance = float3(0, 0, 1);
			}
			else
				shadowRay.radiance = float3(0, 1, 0);
		}
	}
	

	return shadowRay;
}



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= rasterSize.x || id.y >= rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	Interaction isect = Intersections[threadId];

	if (isect.IsHit())
	{
		float lightSourcePdf = 1.0;
		int lightIndex = 0;
		//some error happen in SampleLightSource
		Light light = SampleLightSource(lightSourcePdf, threadId, lightsNum, lightIndex);
		//float testD = Distributions1D[0].y;

		ShadowRay shadowRay = SampleShadowRay(threadId, light, isect);
		shadowRay.lightSourcePdf = lightSourcePdf;
		shadowRay.lightIndex = asfloat(lightIndex);
		ShadowRays[threadId] = shadowRay;
		outputTexture[id.xy] = half4(shadowRay.radiance, 1);
		//outputTexture[id.xy] = half4(isect.normal.xyz, 1);
	}
	else
	{
		outputTexture[id.xy] = half4(lightsNum, 0, 0, 1);
	}
}
