#include "sampler.hlsl"
#include "bvhaccel.hlsl"
#include "materials.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayTraversal

float2 rasterSize;
uniform int    bounces;
uniform int   queueSizeIndex;
uniform float cameraConeSpreadAngle;

//use the matrix to calculate the world space ray
StructuredBuffer<Ray>    Rays;
StructuredBuffer<Light>  lights;
StructuredBuffer<Material> materials;
RWStructuredBuffer<Interaction>       Intersections;
RWStructuredBuffer<PathRadiance> pathRadiances;
//RWStructuredBuffer<int>    pathStates;
RWStructuredBuffer<uint> _RayQueueSizeBuffer;
RWStructuredBuffer<uint> _RayQueue;
RWStructuredBuffer<ShadingMaterial>  _ShadingMaterials;
RWTexture2D<half2>  RayConeGBuffer;
RWTexture2D<half4> outputTexture;

RayCone Propagate(RayCone cone, float surfaceSpreadAngle, float hitT)
{
    RayCone newCone;
    newCone.width = cone.spreadAngle * hitT + cone.width;
    newCone.spreadAngle = cone.spreadAngle + surfaceSpreadAngle;
    return newCone;
}

RayCone ComputeRayCone(Interaction isect, float pixelSpreadAngle)
{
    RayCone rayCone;
    rayCone.width = 0;
    rayCone.spreadAngle = pixelSpreadAngle;
    //float gamma = cameraConeSpreadAngle;
    return Propagate(rayCone, isect.spreadAngle, isect.hitT);
}

[numthreads(8,8,1)]
void RayTraversal(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
        return;

    int threadId = id.x + id.y * rasterSize.x;
    uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
    if (threadId >= queueSize)
        return;
    uint workIndex = _RayQueue[threadId];
    //int pathState = pathStates[threadId];
    //if (pathState > 0)
    //{
    Ray ray = Rays[workIndex];
    Interaction isect = (Interaction)0;//Intersections[threadId];

    bool foundIntersect = ClosestHit(ray, isect);//IntersectBVH(ray, isect);
    PathRadiance pathRadiance = pathRadiances[workIndex];
    if (foundIntersect)
    {
        int meshInstanceIndex = isect.meshInstanceID;
        MeshInstance meshInstance = MeshInstances[meshInstanceIndex];
        int lightIndex = meshInstance.GetLightIndex();
        //ShadingMaterial shadingMaterial;
        //Material material = materials[isect.materialID];
        //UnpackShadingMaterial(material, shadingMaterial, isect, 0);
        //_ShadingMaterials[workIndex] = shadingMaterial;
        
        if (bounces == 0)
        {
            half2 surfaceBeta = RayConeGBuffer[id.xy];
            isect.spreadAngle = cameraConeSpreadAngle;
            isect.coneWidth = cameraConeSpreadAngle * isect.hitT;
        }
        else
        {
            RayCone rayCone = ComputeRayCone(isect, cameraConeSpreadAngle);
            isect.spreadAngle = rayCone.spreadAngle;
            isect.coneWidth = rayCone.width;
        }
        
        //isect.p.w = 1;
        if (lightIndex >= 0 && bounces == 0)
        {
            Light light = lights[lightIndex];
            pathRadiance.li += pathRadiance.beta * light.radiance;
            //color = light.radiance;
            //isect.p.w = 0;
        }

        //just for mipmap test
        //float mipmapLevel = ComputeTextureLOD(isect);
        //outputTexture[id.xy] = half4(mipmapLevel / 5, 0, 0, 1);

        //outputTexture[id.xy] = half4(color, 1);//abs(ray.direction);
        //if (bounces == 1)
        //    outputTexture[id.xy] = half4(abs(ray.direction), 1);
        Intersections[workIndex] = isect;
        pathRadiances[workIndex] = pathRadiance;
        //pathStates[threadId] = 1;
        uint index;
        InterlockedAdd(_RayQueueSizeBuffer[queueSizeIndex + 1], 1, index);
        _RayQueue[index] = workIndex;
    }
    //else
    //{
    //    //sample enviroment map
    //    pathRadiance.li += pathRadiance.beta * float3(0, 0, 0);
    //    isect.p.w = -1;
    //    pathStates[threadId] = 0;
    //    //outputTexture[id.xy] = half4(0, 0, 0, 1);
    //}
//}
    
}
