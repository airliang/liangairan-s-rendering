#include "sampler.hlsl"
#include "rtCommon.hlsl"
#include "bxdf.hlsl"
#include "light.hlsl"
// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel GeneratePath

cbuffer cb
{
	int bounces;
	float2 rasterSize;
	int   queueSizeIndex;
};
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


RWStructuredBuffer<Ray>   Rays;
StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<PathRadiance> pathRadiances;
StructuredBuffer<Material> materials;
RWStructuredBuffer<uint> _RayQueueSizeBuffer;
RWStructuredBuffer<uint> _RayQueue;
//RWStructuredBuffer<int>    pathStates;
//RWTexture2D<half4> outputTexture;

[numthreads(8, 8, 1)]
void GeneratePath(uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	if (id.x >= rasterSize.x || id.y >= rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
	if (threadId >= queueSize)
		return;
	uint workIndex = _RayQueue[threadId];
	
	//int pathState = pathStates[threadId];
	//if (pathState > 0)
	{
		Interaction isect = Intersections[workIndex];
		PathRadiance pathRadiance = pathRadiances[workIndex];
		Ray ray = Rays[workIndex];
		float3 beta = pathRadiance.beta;
		Material material = materials[isect.materialID];
		float3 woLocal = isect.WorldToLocal(-ray.direction/*isect.wo.xyz*/);
		float scatteringPdf = 0;
		float3 wiLocal;
		float2 u = rs.Get2D(workIndex);
		float3 f = SampleLambert(material, woLocal, wiLocal, u, scatteringPdf);
		if (scatteringPdf == 0)
		{
			//pathStates[threadId] = 0;
			return;
		}
		float3 wi = isect.LocalToWorld(wiLocal);
		beta *= f * abs(dot(wi, isect.normal)) / scatteringPdf;
		pathRadiance.beta = beta;
		ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);
		//ray.orig = float4(isect.p.xyz, FLT_MAX);
		//ray.direction = float4(wi, 0);
		//outputTexture[id.xy] = float4(0, 1, 0, 1);

		Rays[workIndex] = ray;

		if (bounces > 3)
		{
			float q = max(0.05, 1 - MaxComponent(beta));
			if (rs.Get1D(workIndex) < q)
			{
				//pathRadiance.beta = 0;
				//pathStates[threadId] = 0;
				return;
			}
			else
				pathRadiance.beta /= 1 - q;
		}

		pathRadiances[workIndex] = pathRadiance;
		uint index;
		InterlockedAdd(_RayQueueSizeBuffer[queueSizeIndex + 1], 1, index);
		_RayQueue[index] = workIndex;
	}
	//else
	//{
	//	//outputTexture[id.xy] = float4(1, 0, 0, 1);
	//}

}
