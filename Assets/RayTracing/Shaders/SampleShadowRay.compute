#include "bvhaccel.hlsl"
#include "sampler.hlsl"
#include "materials.hlsl"
#include "light.hlsl"
#include "distributions.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform int    bounces;
uniform float2 rasterSize;
uniform int    queueSizeIndex;

StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<ShadowRay>  ShadowRays;
StructuredBuffer<Light> lights;
StructuredBuffer<Material> materials;
//StructuredBuffer<ShadingMaterial>  _ShadingMaterials;
//StructuredBuffer<int>    pathStates;
//x pdf y cdf

StructuredBuffer<uint> _RayQueueSizeBuffer;
StructuredBuffer<uint> _RayQueue;
//RWTexture2D<half4> outputTexture;



ShadowRay SampleShadowRay(Light light, Interaction isect, inout RNG rng)
{
	ShadowRay shadowRay = (ShadowRay)0;
	
	float3 wi;
	float lightPdf = 0;
	float3 samplePointOnLight;
	float3 Li = SampleLightRadiance(Distributions1D, light, isect, rng, wi, lightPdf, samplePointOnLight);

	if (lightPdf > 0 && !IsBlack(Li))
	{
		shadowRay.p0 = isect.p.xyz;
		shadowRay.p1 = samplePointOnLight;
		//shadowRay.pdf = triPdf;
		shadowRay.lightPdf = lightPdf;
		//float3 Li = light.radiance;
		//shadowRay.lightNormal = lightPointNormal;
		//float3 wi = normalize(shadowRay.p1 - shadowRay.p0);

		//sample bsdf
		
		//float3 f = LambertBRDF(wiLocal, woLocal, material.kd.xyz) * abs(dot(wi, isect.normal));
		//scatteringPdf = LambertPDF(wiLocal, woLocal);

		bool shadowRayVisible = ShadowRayVisibilityTest(shadowRay, isect.normal);

		if (shadowRayVisible)
		{
			Material material = materials[isect.materialID];
			float3 wiLocal = isect.WorldToLocal(wi);
			float3 woLocal = isect.WorldToLocal(isect.wo.xyz);
			float scatteringPdf = 0;

			float3 f = MaterialBRDF(material, isect, woLocal, wiLocal, scatteringPdf);
			if (!IsBlack(f))
			{
				f *= abs(dot(wi, isect.normal));
				//sample psdf and compute the mis weight
				float weight =
					PowerHeuristic(1, lightPdf, 1, scatteringPdf);
				//weight = 1;
				shadowRay.radiance = f * Li * weight / lightPdf;
			}
			
		}

	}
	
	return shadowRay;
}



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
	if (threadId >= queueSize)
		return;
	uint workIndex = _RayQueue[threadId];
	RNG rng = GetRNG(threadId);
	//int pathState = pathStates[threadId];

	float lightSourcePdf = 1.0;
	//some error happen in SampleLightSource
	float u = Get1D(rng);//rs.Get1D(workIndex);
	int lightIndex = SampleLightSource(u, DistributionDiscripts[0], Distributions1D, lightSourcePdf);
	Light light = lights[lightIndex];
	//float testD = Distributions1D[0].y;
	Interaction isect = Intersections[workIndex];
	ShadowRay shadowRay = SampleShadowRay(light, isect, rng);
	shadowRay.lightSourcePdf = lightSourcePdf;
	shadowRay.lightIndex = asfloat(lightIndex);
	ShadowRays[workIndex] = shadowRay;

	WriteRNG(threadId, rng);
}
