#include "sampler.hlsl"
#include "GPUStructs.hlsl"
#include "bxdf.hlsl"
#include "filters.hlsl"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GeneratePrimary


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

//use the matrix to calculate the world space ray
matrix RasterToCamera;
matrix CameraToWorld;
float2 rasterSize;

RWStructuredBuffer<Ray>    Rays;
RWStructuredBuffer<PathRadiance> pathRadiances;
RWStructuredBuffer<int>    pathStates;

CameraSample GetCameraSample(float2 pRaster, float2 u)
{
    CameraSample camSample;
    float2 filter = ImportanceFilterSample(u);
    camSample.pFilm = pRaster + float2(0.5, 0.5) + filter; // *0.5 - float2(0.5, 0.5);
    return camSample;
}

[numthreads(8,8,1)]
void GeneratePrimary(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= rasterSize.x || id.y >= rasterSize.y)
        return;
    uint threadId = id.x + id.y * rasterSize.x;

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    float2 u = rs.Get2D(threadId);
    
    CameraSample cSample = GetCameraSample(float2(id.x, id.y), u); //rs.GetCameraSample(float2(id.x, id.y), _time);
    float3 pFilm = float3(cSample.pFilm, 0);
    float4 nearplanePoint = mul(RasterToCamera, float4(pFilm, 1));
    nearplanePoint /= nearplanePoint.w;

    Ray ray;
    ray.orig = mul(CameraToWorld, float4(0, 0, 0, 1)).xyz;
    ray.direction = mul(CameraToWorld, float4(normalize(nearplanePoint.xyz), 0));
    ray.tmax = FLT_MAX;
    ray.tmin = 0;
    Rays[threadId] = ray;
    PathRadiance bounceRadiance;
    bounceRadiance.li = 0;
    bounceRadiance.beta = 1.0;
    pathRadiances[threadId] = bounceRadiance;
    pathStates[threadId] = 1;
}

