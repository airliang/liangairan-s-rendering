#include "sampler.hlsl"
#include "bvhaccel.hlsl"
#include "materials.hlsl"
#include "light.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayTraversal

float2 rasterSize;
uniform int    bounces;
uniform int   queueSizeIndex;
uniform float cameraConeSpreadAngle;


//use the matrix to calculate the world space ray
StructuredBuffer<Ray>    Rays;
RWStructuredBuffer<Interaction>       Intersections;
RWStructuredBuffer<PathRadiance> pathRadiances;
//RWStructuredBuffer<int>    pathStates;
RWStructuredBuffer<uint> _RayQueueSizeBuffer;
RWStructuredBuffer<uint> _RayQueue;
//RWStructuredBuffer<ShadingMaterial>  _ShadingMaterials;
Texture2D<half2>  RayConeGBuffer;
RWTexture2D<float3> LastISectRayCone;

//RWTexture2D<half4> outputTexture;

RayCone Propagate(RayCone cone, float surfaceSpreadAngle, float hitT)
{
    RayCone newCone;
    newCone.width = cone.spreadAngle * hitT + cone.width;
    newCone.spreadAngle = cone.spreadAngle + surfaceSpreadAngle;
    return newCone;
}

RayCone ComputeRayCone(float lastisectHitT, half lastSpreadAngle, float distance, float pixelSpreadAngle)
{
    RayCone rayCone;
    rayCone.width = lastSpreadAngle * lastisectHitT;
    rayCone.spreadAngle = lastSpreadAngle;
    //float gamma = cameraConeSpreadAngle;
    return Propagate(rayCone, pixelSpreadAngle, distance);
}



[numthreads(8,8,1)]
void RayTraversal(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= (uint)rasterSize.x || id.y >= (uint)rasterSize.y)
        return;

    int threadId = id.x + id.y * rasterSize.x;
    uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
    if (threadId >= queueSize)
        return;
    uint workIndex = _RayQueue[threadId];

    Ray ray = Rays[workIndex];
    Interaction isect = (Interaction)0;//Intersections[threadId];
    float3 lastCone = LastISectRayCone[id.xy];
    PathRadiance pathRadiance = pathRadiances[workIndex];
    //bool foundIntersect = false;
    if (bounces == 0)
    {
        bool foundIntersect = ClosestHit(ray, isect);
        if (foundIntersect)
        {
            int meshInstanceIndex = isect.meshInstanceID;
            MeshInstance meshInstance = MeshInstances[meshInstanceIndex];
            int lightIndex = meshInstance.GetLightIndex();

            lastCone.x = cameraConeSpreadAngle;
            lastCone.y = cameraConeSpreadAngle * isect.hitT;

            lastCone.z = isect.hitT;
            //LastISectRayCone[id.xy] = lastCone;

            //isect.p.w = 1;
            if (lightIndex >= 0)
            {
                Light light = lights[lightIndex];
                pathRadiance.li += pathRadiance.beta * light.radiance;
            }

            Intersections[workIndex] = isect;
        }
        else
        {
            //sample enviroment map
            if (_EnvLightIndex >= 0)
            {
                pathRadiance.li += pathRadiance.beta * EnviromentLightLe(ray.direction);
                pathRadiances[workIndex] = pathRadiance;
                return;
            }
        }
    }
    else
    {
        isect = Intersections[workIndex];
        half2 surfaceBeta = RayConeGBuffer[id.xy];
        RayCone rayCone = ComputeRayCone(isect.hitT, lastCone.x, lastCone.z, surfaceBeta.r);
        lastCone.x = rayCone.spreadAngle;
        lastCone.y = rayCone.width;
        lastCone.z = isect.hitT;
    }

    pathRadiances[workIndex] = pathRadiance;
    LastISectRayCone[id.xy] = lastCone;
	uint index;
    InterlockedAdd(_RayQueueSizeBuffer[queueSizeIndex + 1], 1, index);
    _RayQueue[index] = workIndex;
}
