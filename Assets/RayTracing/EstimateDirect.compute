// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "sampler.hlsl"
#include "bxdf.hlsl"
#include "bvhaccel.hlsl"
#include "distributions.hlsl"

cbuffer cb
{
    int    bounces;
    int    lightsNum;
    float2 rasterSize;
};

StructuredBuffer<Interaction>  Intersections;
StructuredBuffer<ShadowRay>  ShadowRays;
StructuredBuffer<Light> lights;
StructuredBuffer<Material> materials;
RWStructuredBuffer<PathRadiance> pathRadiances;
StructuredBuffer<int>    pathStates;
//x pdf y cdf
StructuredBuffer<float2> Distributions1D;
//RWTexture2D<half4> outputTexture;

float AreaLightPdf(Ray ray, Light light, float3 orig, float3 wi)
{
    //intersect the light mesh triangle
    float bvhHit = ray.tmax;
    int meshHitTriangleIndex;  //wood triangle addr
    float lightPdf = 0;
    DistributionDiscript discript = DistributionDiscripts[light.distributionDiscriptIndex];
    int distributionIndex = discript.start;
    //getting the mesh of the light
    MeshInstance meshInstance = MeshInstances[light.meshInstanceID];

    //convert to mesh local space
    Ray rayTemp = TransformRay(meshInstance.worldToLocal, ray);
    
    //check the ray intersecting the light mesh
    if (IntersectMeshBVHP(rayTemp, meshInstance.GetBVHOffset(), bvhHit, meshHitTriangleIndex))
    {
        int triAddr = meshHitTriangleIndex;
        int vIndex0 = WoodTriangleIndices[triAddr];
        int vIndex1 = WoodTriangleIndices[triAddr + 1];
        int vIndex2 = WoodTriangleIndices[triAddr + 2];
        float3 p0 = Vertices[vIndex0].position.xyz;
        float3 p1 = Vertices[vIndex1].position.xyz;
        float3 p2 = Vertices[vIndex2].position.xyz;

        p0 = mul(meshInstance.localToWorld, float4(p0, 1.0));
        p1 = mul(meshInstance.localToWorld, float4(p1, 1.0));
        p2 = mul(meshInstance.localToWorld, float4(p2, 1.0));

        lightPdf = 1.0 / length(cross(p0 - p1, p0 - p2));

        distributionIndex += vIndex0 / 3;

        lightPdf *= DiscretePdf(distributionIndex, Distributions1D);
    }

    return lightPdf;
}


float3 EstimateDirect(ShadowRay shadowRay, Interaction isect, float2 u)
{
    float3 Ld = shadowRay.radiance;
    Material material = materials[isect.materialID];
    float3 woLocal = isect.WorldToLocal(isect.wo);
    float3 wi;
    float scatteringPdf = 0;
    float3 wiLocal;
    float3 f = SampleLambert(material, woLocal, wiLocal, u, scatteringPdf);
    
    wi = isect.LocalToWorld(wiLocal);
    f *= abs(dot(wi, isect.normal));

    if (scatteringPdf > 0)
    {
        Light light = lights[asint(shadowRay.lightIndex)];
        //for test
        //float3 lightPos = float3(-2.750401, 5.5, -6.640179);
        //wi = normalize(lightPos - isect.p.xyz);
        //test end
        Ray ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);

        float lightPdf = AreaLightPdf(ray, light, isect.p, wi);
        if (lightPdf > 0)
        {
            //caculate the mis weight
            float weight = PowerHeuristic(1, lightPdf, 1, scatteringPdf);
            Ld += f * light.radiance * weight / scatteringPdf;
        }
    }

    return Ld;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= rasterSize.x || id.y >= rasterSize.y)
        return;

    uint threadId = id.x + id.y * rasterSize.x;
    int pathState = pathStates[threadId];
    if (pathState == 1)
    {
        ShadowRay shadowRay = ShadowRays[threadId];
        Interaction isect = Intersections[threadId];

        //if (isect.IsHit())
        {
            PathRadiance pathRadiance = pathRadiances[threadId];
            float2 u = rs.Get2D(threadId);

            float3 Li = EstimateDirect(shadowRay, isect, u);

            Li /= shadowRay.lightSourcePdf;

            pathRadiance.li += Li * pathRadiance.beta;
            pathRadiances[threadId] = pathRadiance;
            //outputTexture[id.xy] = half4(pathRadiance.li * 5, 1);

            //int lightIndex = asint(shadowRay.lightIndex);
            //Light light = lights[lightIndex];
            //MeshInstance meshInstance = MeshInstances[light.meshInstanceID];
            //if (light.meshInstanceID == 5)
            //{
            //    outputTexture[id.xy] = half4(1, 1, 1, 1);
            //}
        }
        //else
        //{
            //outputTexture[id.xy] = half4(1, 0, 0, 1);
        //}
    }
    
}
