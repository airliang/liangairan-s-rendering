#include "sampler.hlsl"
#include "rtCommon.hlsl"
#include "bxdf.hlsl"
#include "light.hlsl"
// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel GeneratePath

cbuffer cb
{
	int bounces;
	float2 rasterSize;
};
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


RWStructuredBuffer<Ray>   Rays;
StructuredBuffer<Interaction>  Intersections;
RWStructuredBuffer<PathRadiance> pathRadiances;
StructuredBuffer<Material> materials;
RWStructuredBuffer<int>    pathStates;
//RWTexture2D<half4> outputTexture;

[numthreads(8, 8, 1)]
void GeneratePath(uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	if (id.x >= rasterSize.x || id.y >= rasterSize.y)
		return;

	uint threadId = id.x + id.y * rasterSize.x;
	
	int pathState = pathStates[threadId];
	if (pathState > 0)
	{
		Interaction isect = Intersections[threadId];
		PathRadiance pathRadiance = pathRadiances[threadId];
		float3 beta = pathRadiance.beta;
		Material material = materials[isect.materialID];
		float3 woLocal = isect.WorldToLocal(isect.wo.xyz);
		float scatteringPdf = 0;
		float3 wiLocal;
		float2 u = rs.Get2D(threadId);
		float3 f = SampleLambert(material, woLocal, wiLocal, u, scatteringPdf);
		if (/*f.rgb == 0 || */scatteringPdf == 0)
		{
			pathStates[threadId] = 0;
			return;
		}
		float3 wi = isect.LocalToWorld(wiLocal);
		beta *= f * abs(dot(wi, isect.normal)) / scatteringPdf;
		pathRadiance.beta = beta;
		Ray ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);
		//ray.orig = float4(isect.p.xyz, FLT_MAX);
		//ray.direction = float4(wi, 0);
		//outputTexture[id.xy] = float4(0, 1, 0, 1);

		Rays[threadId] = ray;

		if (bounces > 3)
		{
			float q = max(0.05, 1 - beta.y);
			if (rs.Get1D(threadId) < q)
			{
				pathRadiance.beta = 0;
				pathStates[threadId] = 0;
			}
			else
				pathRadiance.beta /= 1 - q;
		}

		pathRadiances[threadId] = pathRadiance;
	}
	else
	{
		//outputTexture[id.xy] = float4(1, 0, 0, 1);
	}

}
