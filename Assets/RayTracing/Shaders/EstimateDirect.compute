// Each #kernel tells which function to compile; you can have many kernels

#include "sampler.hlsl"
#include "materials.hlsl"
#include "bvhaccel.hlsl"
#include "distributions.hlsl"
#include "light.hlsl"

#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols

int    bounces;
float2 rasterSize;
int    queueSizeIndex;


StructuredBuffer<Interaction>  Intersections;
StructuredBuffer<ShadowRay>  ShadowRays;
RWStructuredBuffer<PathRadiance> pathRadiances;

RWStructuredBuffer<uint> _RayQueueSizeBuffer;
RWStructuredBuffer<uint> _RayQueue;
RWStructuredBuffer<Ray>   Rays;
//RWTexture2D<half4> outputTexture;



float3 EstimateDirect(Interaction isect, Material material, inout RNG rng, out float scatteringPdf, out float3 wi)
{
    //float3 Ld = shadowRay.radiance;
    float3 woLocal = isect.WorldToLocal(isect.wo);
    //float3 wi;
    //float scatteringPdf = 0;
    float3 wiLocal;
    float2 u = Get2D(rng);
    float3 f = SampleMaterialBRDF(material, isect, woLocal, wiLocal, scatteringPdf, rng);
    
    wi = isect.LocalToWorld(wiLocal);
    return f;
}

float3 MIS_BSDF_OLD(Interaction isect, Material material, ShadowRay shadowRay, inout RNG rng, out float scatteringPdf, out float3 beta, out Ray ray)
{
    //float3 wi;
    //float3 f = EstimateDirect(isect, material, rng, scatteringPdf, wi);
    //ray = (Ray)0;
    //beta = 0;
    //float3 ld = 0;
    float3 ld = float3(0, 0, 0);
    float3 woLocal = isect.WorldToLocal(isect.wo);
    //float3 wi;
    //float scatteringPdf = 0;
    ray = (Ray)0;
    //PathVertex pathVertex = (PathVertex)0;
    float3 wiLocal;
    float2 u = Get2D(rng);
    scatteringPdf = 0;
    beta = 0;
    float3 f = SampleMaterialBRDF(material, isect, woLocal, wiLocal, scatteringPdf, rng);
    float3 wi = isect.LocalToWorld(wiLocal);

    if (!IsBlack(f) && scatteringPdf > 0)
    {
        ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);
        beta = f * abs(dot(wi, isect.normal)) / scatteringPdf;
        int shadowLightIndex = asint(shadowRay.lightIndex);
        Light light = lights[shadowLightIndex];
        Interaction lightISect = (Interaction)0;
        bool found = ClosestHit(ray, lightISect);
        float3 li = 0;
        float weight = 0;
        float lightPdf = 0;
        if (found)
        {
            lightPdf = AreaLightPdf(light, isect, wi, _UniformSampleLight) * shadowRay.lightSourcePdf;
            if (lightPdf > 0)
            {
                //caculate the mis weight
                int meshInstanceIndex = lightISect.meshInstanceID;
                MeshInstance meshInstance = MeshInstances[meshInstanceIndex];

                if (meshInstance.GetLightIndex() == shadowLightIndex)
                    li = Light_Le(wi, light);
            }
        }
        else if (_EnvLightIndex >= 0)
        {
            Light envlight = lights[shadowLightIndex];
            li = Light_Le(wi, envlight);
            if (light.type != EnvLightType)
            {
                float lightSourcePdf = LightSourcePmf(_EnvLightIndex, _UniformSampleLight);
                lightPdf = EnvLightLiPdf(wi, _UniformSampleLight) * lightSourcePdf;
            }
        }

        weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);

        //ld = li * weight * beta;
        ld = f * abs(dot(wi, isect.normal)) * li * weight / scatteringPdf;
    }
    return ld;
}

float3 MIS_BSDF(Interaction isect, Material material, ShadowRay shadowRay, inout RNG rng, out PathVertex pathVertex, out Ray ray)
{
    //return MIS_BSDF_OLD(isect, material, shadowRay, rng, scatteringPdf, beta, ray);
    float3 ld = float3(0, 0, 0);
    float3 woLocal = isect.WorldToLocal(isect.wo);
    //float3 wi;
    float scatteringPdf = 0;
    ray = (Ray)0;
    pathVertex = (PathVertex)0;
    float3 wiLocal;
    float2 u = Get2D(rng);
    scatteringPdf = 0;
    //beta = 0;
    float3 f = SampleMaterialBRDF(material, isect, woLocal, wiLocal, scatteringPdf, rng);
    float3 wi = isect.LocalToWorld(wiLocal);
    f *= abs(dot(wi, isect.normal));

    if (!IsBlack(f) && scatteringPdf > 0)
    {
        //beta = f * abs(dot(wi, isect.normal)) / scatteringPdf;
        int shadowLightIndex = asint(shadowRay.lightIndex);
        Light light = lights[shadowLightIndex];
        ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);
        Interaction lightISect = (Interaction)0;
        bool found = ClosestHit(ray, lightISect);
        pathVertex.nextISect = lightISect;
        pathVertex.found = found ? 1 : 0;
        float3 li = 0;
        float lightPdf = 0;

        if (found)
        {
            lightPdf = AreaLightPdf(light, isect, wi, _UniformSampleLight) * shadowRay.lightSourcePdf;

            if (lightPdf > 0)
            {
                int meshInstanceIndex = lightISect.meshInstanceID;
                MeshInstance meshInstance = MeshInstances[meshInstanceIndex];

                if (meshInstance.GetLightIndex() == shadowLightIndex)
                    li = Light_Le(wi, light);
            }
        }
        else if (_EnvLightIndex >= 0)//(light.type == EnvLightType)
        {
            Light envLight = lights[_EnvLightIndex];
            li = Light_Le(wi, envLight);
            
            if (light.type != EnvLightType)
            {
                float lightSourcePdf = LightSourcePmf(_EnvLightIndex, _UniformSampleLight);
                lightPdf = EnvLightLiPdf(wi, _UniformSampleLight) * lightSourcePdf;
            }
        }

        float weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);
        ld = f * li * weight / scatteringPdf;
        //ld = li * weight * beta;
    }

    pathVertex.wi = wi;
    pathVertex.bsdfVal = f;
    pathVertex.bsdfPdf = scatteringPdf;
    //beta = f / scatteringPdf;
    return ld;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= rasterSize.x || id.y >= rasterSize.y)
        return;

    uint threadId = id.x + id.y * rasterSize.x;
    uint queueSize = _RayQueueSizeBuffer[queueSizeIndex];
    if (threadId >= queueSize)
        return;
    uint workIndex = _RayQueue[threadId];
    RNG rng = GetRNG(threadId);

    ShadowRay shadowRay = ShadowRays[workIndex];
    Interaction isect = Intersections[workIndex];
    PathRadiance pathRadiance = pathRadiances[workIndex];
    Material material = materials[isect.materialID];
    //float2 u = Get2D(rng);//rs.Get2D(workIndex);
    //float3 beta = 1; // = pathRadiance.beta;
    float scatteringPdf = 0;
    float3 wi;
    float3 f = EstimateDirect(isect, material, rng, scatteringPdf, wi);
	int shadowLightIndex = asint(shadowRay.lightIndex);
    Light light = lights[shadowLightIndex];
    float3 Li = shadowRay.radiance;
	Ray ray;
    PathVertex pathVertex = (PathVertex)0;
    float3 beta = 0;
	Li += MIS_BSDF(isect, material, shadowRay, rng, pathVertex, ray);
    //Li += MIS_BSDF_OLD(isect, material, shadowRay, rng, scatteringPdf, beta, ray);
	/*
    if (!IsBlack(f) && scatteringPdf > 0)
    {
        ray = SpawnRay(isect.p.xyz, wi, isect.normal, FLT_MAX);
        beta = f * abs(dot(wi, isect.normal)) / scatteringPdf;
        int shadowLightIndex = asint(shadowRay.lightIndex);
        Light light = lights[shadowLightIndex];
		Interaction lightISect = (Interaction)0;
        bool found = ClosestHit(ray, lightISect);
        float3 ld = 0;
        float weight = 0;
        float lightPdf = 0;
		if (found)
		{
            lightPdf = AreaLightPdf(light, isect, wi, _UniformSampleLight) * shadowRay.lightSourcePdf;
			if (lightPdf > 0)
			{
				//caculate the mis weight
				int meshInstanceIndex = lightISect.meshInstanceID;
				MeshInstance meshInstance = MeshInstances[meshInstanceIndex];

				if (meshInstance.GetLightIndex() == shadowLightIndex)
                    ld = Light_Le(wi, light);
			}
		}
		else if (_EnvLightIndex >= 0)
		{
            Light envlight = lights[shadowLightIndex];
            ld = Light_Le(wi, envlight);
            if (light.type != EnvLightType)
            {
                float lightSourcePdf = LightSourcePmf(_EnvLightIndex, _UniformSampleLight);
                lightPdf = EnvLightLiPdf(wi, _UniformSampleLight) * lightSourcePdf;
            }
		}

        weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);
		
		Li += ld * weight * beta;
    }
	*/
    //Li /= shadowRay.lightSourcePdf;
    pathRadiance.li += Li * pathRadiance.beta;
    //scatteringPdf = pathVertex.bsdfPdf;
	beta = pathVertex.bsdfVal / pathVertex.bsdfPdf;
    if (pathVertex.bsdfPdf > 0)
    {
        bool breakPath = false;
        pathRadiance.beta *= beta;

        if (bounces > 3)
        {
            float q = max(0.05, 1 - MaxComponent(pathRadiance.beta));
            if (Get1D(rng) < q)
            {
                breakPath = true;
            }
            else
                pathRadiance.beta /= 1 - q;
        }

        if (!breakPath)
        {
            Rays[workIndex] = ray;
            uint index;
            InterlockedAdd(_RayQueueSizeBuffer[queueSizeIndex + 1], 1, index);
            _RayQueue[index] = workIndex;
        }
    }
    //outputTexture[id.xy] = half4(f, 1);
    pathRadiances[workIndex] = pathRadiance;
    WriteRNG(threadId, rng);
}
